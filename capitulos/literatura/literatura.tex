\chapter{Referêncial Teórico}

É apresentado nesse capítulo um conjunto de definições relevantes para o tema dessa proposta de trabalho. Foi realizada uma pesquisa sistemática para selecionar os principais tópicos apoiam o entendimento deste trabalho. Os detalhes estão descritos nas próximas seções.

\section{Teste de Software}

Teste de software é o processo que realiza a avaliação do sistema ou de seus componentes com o objetivo de desvendar o comportamento para garantir que os seus requisitos estão de acordo com o esperado ou não. Em outras palavras teste é execução do sistema, a fim de identificar eventuais lacunas, erros ou requisitos que não foram implementados de acordo com as necessidades requeridas \cite{tutorialsPoint}. Segundo \cite{ansiieee1059}, Teste pode ser definido como o processo de análise do software para detectar as diferenças entre condições existentes e necessárias e avaliar as características do software.

Um bom teste pode ser aquele que tem alta probabilidade de encontrar erros que ainda não foram expostos e um teste bem sucedido é aquele que revela um erro ainda não-descoberto. O teste pode ser manual, automatizado, ou ainda a combinação de ambos \cite{Pressman2002}. A redução de custo, tempo e retrabalho são proporcionais ao quão cedo o processo de testes for iniciado \cite{tutorialsPoint}.

\section{Tipos de Teste de software}

Testes de software podem ser divididos em duas categorias, testes manuais e automatizados.

\subsection{Testes Manuais}

		Este tipo de teste é feito pela execução manual do software, ou seja, sem o uso de qualquer ferramenta automatizada ou qualquer script. O testador assume o papel do usuário final para realizar os testes e identificar qualquer comportamento que não seja esperado ou revelar defeitos. Costumam usar planos de teste, casos de teste e/ou cenários para garantir a integridade dos testes. Também pode ser incluso dentro deste tipo os testes exploratórios, no qual o testador irá explorar o software com o intuito de encontrar erros\cite{tutorialsPoint}.
		
\subsection{Testes Automatizados}

Testes automatizados podem ser definidos como automação de atividades de teste de software, incluindo o desenvolvimento e execução de scripts de testes, verificação de requisitos, como também a utilização de ferramentas de teste automatizadas \cite{Dustin1999}.
 
Entre as razões para o uso da automação dos testes de software podemos citar, por exemplo, executar testes manuais é mais demorado, uso da automação de testes aumenta a  eficiência processo, em um fatia particular temos os testes de regressão, onde os casos de testes são executados de forma iterativa, depois de alterações no software \cite{Dustin1999}.
		
\section{Níveis de testes de Software}

Em \cite{Pressman2002} aponta que a realização de testes apenas quando o sistema está construído é uma abordagem ineficaz. Segundo o autor, a estratégia de testes de software de possuir uma abordagem incremental, começando com os testes de unidades, seguindo com os testes de integração, culminando com os testes do sistema final e ainda acoplando testes que se enquadrem em testes de aceitação.

\subsection{Testes Funcionais}

Este tipo de teste é baseado nas especificações do software que será testado, a aplicação será testada através do fornecimento de entradas e em seguida, os resultados serão examinados para garantir a conformidade com os requisitos de tal funcionalidade \cite{tutorialsPoint}. Basicamente testar se os componentes e o sistema estão feitos, uma atividade ou uma função especifica do código está coerente com o esperado. Neste nível de teste perguntas como "O usuário poderá fazer isso?" ou "Esta função em particular funciona?" podem ser validadas tipicamente através de especificações de requisitos ou funcional \cite{Leung1990}. 

\subsection{Testes Unitários}

É a menor parte que pode ser testada do código que compõe o software, são de granulação fina, comportamento extremamente rápido, por exemplo, métodos de uma classe, uma classe ou classes que podem estar relacionadas. Não verificam o comportamento de unidades integradas com outros serviços ou dependências, garantem que sua função como unidade estão funcionando. Seu objetivo é isolar parte do programa e mostrar que partes individuais estão corretas em termos de requisitos e funcionalidades \cite{James2012}.  Existe um limite para cenários e dados que podem ser aplicados ao nível de testes de unidade, quando é nítido esse esgotamento é necessário o mistura com outras unidades do código e diferentes tipos de testes \cite{tutorialsPoint}.

\subsection{Testes de Integração}

Neste caso, é realizada a combinação de partes da aplicação que serão agrupadas para determinar se funcionamento desse conjunto está trabalhando corretamente \cite{tutorialsPoint}. Alguns defeitos não podem ser encontrados a nível unitário, mas são revelados através da integração com núcleos específicos \cite{Pachawan2014}.

\subsection{Teste de Sistema}

Após a realização dos testes de integração, uma vezes que todos os componentes foram integrados, os testes do sistema como um todo são agora efetuados para garantir que a aplicação atende aos padrões de qualidade desejado \cite{tutorialsPoint}. A aplicação é testada minuciosamente para validar especificações funcionais e técnicas, é construído um ambiente o mais próximo possível do ambiente de produção, para que os testes sejam executados em um ambiente que corresponda ao ambiente no qual o sistema será implantado. O teste do sistema nos retornará a validação dos requisitos de negócio e da arquitetura como todo da aplicação.

\subsection{Teste de Regressão}

Significa testar uma aplicação após o seu código fonte ter sido modificado para validar se ainda continua funcionando devidamente. Consiste em reexecutar casos de testes existentes e verificar se alterações de código não interfere em funcionalidades que estavam trabalhando corretamente, se foram inseridos novos erros ou causa problemas em erros que já foram reparados \cite{Leung1990}. Afim de identificar defeitos introduzidos por novas funcionalidades ou correção de defeitos.

\subsection{Testes de Aceitação}

Nível mais alto que trata da aplicação como uma caixa preta, sem dúvidas considerado um dos mais importantes entre os outros, este tipo de teste é feito na grande parte  pelo time de garantia da qualidade \cite{James2012}. Onde todo time verificará se o produto preenche as especificações solicitadas e satisfaz os requisitos dos clientes. O time responsável terá um conjunto de cenários previamente escritos e que serão usados no momento da validação. Durante a fase de validação outros cenários podem  surgir para aumentar a cobertura dos testes. Testes de aceitação não são apenas para identificação de erros de interfaces, mas também para encontrar divergências que poderão resultar em quebra ou erros graves do sistema \cite{tutorialsPoint}. Para a execução de desse tipo de testes é necessário definir critérios de aceitação a partir dos requisitos do software, estabelecendo como o teste será conduzido e a partir desses critérios, avaliar se o produto satisfaz aos requisitos \cite{SoftexRecife}.

\subsection{Testes Não-Funcionais}

Requisitos não funcionais são declarações que define as qualidades globais ou atributos a serem atendidos pelo sistema resultante \cite{Kirner1996}. Estes requisitos, ao contrário dos requisitos funcionais, não expressão nenhuma função a ser realizada pelo software, e sim comportamentos e restrições que este software deve satisfazer \cite{Cysneiros1997}. Os testes desses requisitos são normalmente executados com ajuda de ferramentas especializadas, com grande planejamento, avaliação arquitetural, aplicando técnicas avançadas \cite{tutorialsPoint}.

Alguns dos considerados mais importantes tipos de validação não funcionais são \cite{tutorialsPoint}:
\begin{itemize}
	\item Teste de Performance
	\item Teste de Carga
	\item Teste de Stress
	\item Teste de Segurança
	\item Teste de Usabilidade
	\item Teste de Portabilidade
\end{itemize}